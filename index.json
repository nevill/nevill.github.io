[{"categories":null,"contents":"总结记录一下在 unRAID(v6.11) 中如何直通核显 gpu，usb 设备等。\nCPU: AMD R7-5700G Motherboard: Asus TUF Gaming B550 Plus WIFI II Memory: 2 x 32G DDR3200    主机配置   设置 unRAID 启动方式为 Legacy。在主机的 BIOS 设置打开 CSM / Legacy Boot 等选项。 设置内置显卡为主要启动项，打开 multiple display 选项，并分配最大的共享内存。 打开 SVM（虚拟化支持）选项。     设置 unRAID    进入 unRAID 中配置 System Devices 分组，并选定 Bind Selected to IOMMU 中分得越开越利于后续步骤，具体操作步骤可以参考[1]。需要注意的是，通过反复拔插确定好需要直通的 usb port 的位置以及对应的 usb controller，后面整个直通给虚拟机，这样子虚拟机就可以轻松使用 usb 设备了。\n  在 unRAID 中禁用 amdgpu 内核模块(因为后面需要直通它，主机就不使用了)\n  # /boot/config/modprobe.d/amdgpu.conf blacklist amdgpu 新建虚拟 Windows 10 主机。 可以使用下面的配置  Machine: Q35-6.2 BIOS: SeaBIOS // 必选 Hyper-V: yes 其他 I/O 设备，如网卡、硬盘尽量使用 virtio 类型连接。光驱选择 SATA 连接。\n先在 VNC 作为主要显示输出的情况下安装 Windows 10，安装过程中需要依赖 virtio.iso，具体过程参考[2]。 安装完 Windows 以后打开远程桌面，确保能够通过别的机器连接上，后续显卡驱动安装的步骤会通过远程连接进行。 Dump 显卡 vbios，具体方法可以参考[3][4]，把文件改名为 .rom 放在 /mnt/user/system/graph-bios/ 目录。 修改虚拟机的 XML 配置，主要参考[5][6][7]。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  \u0026lt;hyperv\u0026gt; \u0026lt;!-- 省略若干行 --\u0026gt; \u0026lt;vendor_id state=\u0026#39;on\u0026#39; value=\u0026#39;AMD5700GOFDL\u0026#39;/\u0026gt; \u0026lt;/hyperv\u0026gt; \u0026lt;kvm\u0026gt; \u0026lt;hidden state=\u0026#39;on\u0026#39;/\u0026gt; \u0026lt;/kvm\u0026gt; \u0026lt;!-- 省略若干行 --\u0026gt; \u0026lt;hostdev mode=\u0026#39;subsystem\u0026#39; type=\u0026#39;pci\u0026#39; managed=\u0026#39;yes\u0026#39;\u0026gt; \u0026lt;driver name=\u0026#39;vfio\u0026#39;/\u0026gt; \u0026lt;source\u0026gt; \u0026lt;address domain=\u0026#39;0x0000\u0026#39; bus=\u0026#39;0x08\u0026#39; slot=\u0026#39;0x00\u0026#39; function=\u0026#39;0x0\u0026#39;/\u0026gt; \u0026lt;!-- --\u0026gt; \u0026lt;/source\u0026gt; \u0026lt;rom file=\u0026#39;/mnt/user/system/graph-bios/vbios_1638.rom\u0026#39;/\u0026gt; \u0026lt;!-- 此处表明是显卡 --\u0026gt; \u0026lt;address type=\u0026#39;pci\u0026#39; domain=\u0026#39;0x0000\u0026#39; bus=\u0026#39;0x04\u0026#39; slot=\u0026#39;0x00\u0026#39; function=\u0026#39;0x0\u0026#39; multifunction=\u0026#39;on\u0026#39;/\u0026gt; \u0026lt;/hostdev\u0026gt; \u0026lt;hostdev mode=\u0026#39;subsystem\u0026#39; type=\u0026#39;pci\u0026#39; managed=\u0026#39;yes\u0026#39;\u0026gt; \u0026lt;driver name=\u0026#39;vfio\u0026#39;/\u0026gt; \u0026lt;source\u0026gt; \u0026lt;address domain=\u0026#39;0x0000\u0026#39; bus=\u0026#39;0x08\u0026#39; slot=\u0026#39;0x00\u0026#39; function=\u0026#39;0x1\u0026#39;/\u0026gt; \u0026lt;!-- 此处 domain, bus, slot 值与显卡相同，表示是显卡上的声音输出设备 --\u0026gt; \u0026lt;/source\u0026gt; \u0026lt;address type=\u0026#39;pci\u0026#39; domain=\u0026#39;0x0000\u0026#39; bus=\u0026#39;0x04\u0026#39; slot=\u0026#39;0x00\u0026#39; function=\u0026#39;0x1\u0026#39;/\u0026gt; \u0026lt;!-- 修改此处的 bus值与显卡对应的相同，并将 function 改为 0x1 --\u0026gt; \u0026lt;/hostdev\u0026gt; \u0026lt;!-- 省略若干行 --\u0026gt; \u0026lt;qemu:commandline\u0026gt; \u0026lt;qemu:arg value=\u0026#39;-set\u0026#39;/\u0026gt; \u0026lt;qemu:arg value=\u0026#39;device.hostdev0.x-vga=on\u0026#39;/\u0026gt; \u0026lt;/qemu:commandline\u0026gt; \u0026lt;/domain\u0026gt; \u0026lt;!-- 如果上面的 commandline 在启动时候报关于 hostdev0 not defined 错误，用下面的配置替代 \u0026lt;qemu:override\u0026gt; \u0026lt;qemu:device alias=\u0026#39;hostdev0\u0026#39;\u0026gt; \u0026lt;qemu:frontend\u0026gt; \u0026lt;qemu:property name=\u0026#39;x-vga\u0026#39; type=\u0026#39;bool\u0026#39; value=\u0026#39;true\u0026#39;/\u0026gt; \u0026lt;/qemu:frontend\u0026gt; \u0026lt;/qemu:device\u0026gt; \u0026lt;/qemu:override\u0026gt; --\u0026gt;   启动 Windows 虚拟机，远程连接上以后安装 AMD 驱动程序，然后以管理员权限执行 RadeonResetBugFixService install。这个补丁必须安装，否则会出现重启或关闭虚拟机后主机 CPU 飙升的 bug。     参考   Quick and Easy PCIe Device Passthrough for VMs 如何安装使用 virtio 使用 UBU 从主板 BIOS 中抽出 vBios How to Easily Dump the vBios from any GPU for Passthrough Advanced GPU passthrough techniques on Unraid Unraid Forum 上的讨论 关于 hostdev0 not defined 错误的讨论  ","date":"Nov 27","permalink":"https://nevill.github.io/posts/unraid-passthrough/","tags":null,"title":"Unraid Passthrough"},{"categories":null,"contents":"运行一个取字符串地址的程序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // hello.go package main import ( \u0026#34;fmt\u0026#34; ) func main() { str := \u0026#34;Hello Golang!\u0026#34; strPtr := \u0026amp;str fmt.Printf(\u0026#34;address of str = %p\\n\u0026#34;, strPtr) byteArray := []byte(str) fmt.Printf(\u0026#34;address of byte array = %p\\n\u0026#34;, byteArray) fmt.Scanln() }   观察到输出\naddress of str = 0xc00008a210 address of byte array = 0xc0000ac000 这两个地址的值并不相同。\n正好在学习使用 crash utility，可以用来观察一下内存结构\ncrash\u0026gt; rd -32 0xc00008a210 8 c00008a210: 004a3cfc 00000000 0000000d 00000000 .\u0026lt;J............. c00008a220: 005383e0 00000000 00538420 00000000 ..S..... .S..... crash\u0026gt; rd -a 0xc0000ac000 c0000ac000: Hello Golang! 猜测，0xc00008c210 这个指针指向了一个字符串真正的地址，即 0x004a3cfc 才是存放的内存地址。 尝试读取一下：\ncrash\u0026gt; rd -8 0x004a3cfc 32 4a3cfc: 48 65 6c 6c 6f 20 47 6f 6c 61 6e 67 21 4d 61 73 Hello Golang!Mas 4a3d0c: 61 72 61 6d 5f 47 6f 6e 64 69 4d 65 6e 64 65 5f aram_GondiMende_ 果然找到了。\n翻一下代码，有一个 stringStruct\n1 2 3 4 5  // runtime/string.go type stringStruct struct { str unsafe.Pointer len int }   同时，观察到 0xc00008a218 这个地址的值 0x0000000d 即 Hello Golang! 字符串的长度 13。即验证了 0xc00008a210 这个地址对应的结构体。 那么通过 []byte(str) 强制转换以后为什么会返回另外一个内存地址 0xc0000ac000 而没有返回 0x004a3cfc 呢？ 原因也很简单， string 类型应该是不可修改的 (immutable)[^1]，也无法通过 \u0026amp;str[i] 来获取其某一个 byte 的地址。\n可以查看一下汇编：\n// go tool compile -S hello.go // ... 0x0085 00133 (hello.go:11)\tMOVQ\t\u0026quot;\u0026quot;.\u0026amp;str+56(SP), CX 0x008a 00138 (hello.go:11)\tMOVQ\t(CX), BX 0x008d 00141 (hello.go:11)\tMOVQ\t8(CX), CX 0x0091 00145 (hello.go:11)\tXORL\tAX, AX 0x0093 00147 (hello.go:11)\tPCDATA\t$1, $0 0x0093 00147 (hello.go:11)\tCALL\truntime.stringtoslicebyte(SB) 0x0098 00152 (hello.go:12)\tCALL\truntime.convTslice(SB) 0x009d 00157 (hello.go:12)\tMOVUPS\tX15, \u0026quot;\u0026quot;..autotmp_29+64(SP) 0x00a3 00163 (hello.go:12)\tLEAQ\ttype.[]uint8(SB), CX 0x00aa 00170 (hello.go:12)\tMOVQ\tCX, \u0026quot;\u0026quot;..autotmp_29+64(SP) 0x00af 00175 (hello.go:12)\tMOVQ\tAX, \u0026quot;\u0026quot;..autotmp_29+72(SP) // ... 这里调用了一个 runtime.stringtoslicebyte\n1 2 3 4 5 6 7 8 9 10 11  func stringtoslicebyte(buf *tmpBuf, s string) []byte { var b []byte if buf != nil \u0026amp;\u0026amp; len(s) \u0026lt;= len(buf) { *buf = tmpBuf{} b = buf[:len(s)] } else { b = rawbyteslice(len(s)) } copy(b, s) return b }   可以看到，最后会调用 copy 将源内容复制到一个新的 []byte 切片中。\n总结一下：\n string 类型结构仅含两个元素，一个指向具体内容的指针和字符串长度 string 类型是不可修改的，所以在强制转换类型的时候发生了复制 写这篇主要目的是展示 crash utility 怎么用 :)  参考： [^1] https://go.dev/ref/spec#String_types\n","date":"Jan 11","permalink":"https://nevill.github.io/posts/string-in-go/","tags":null,"title":"String in Go"},{"categories":null,"contents":"随着 Docker Desktop 越来越笨重，我现在已经用 Lima 完全来替换掉它。\n   介绍  Lima 是一个在 macOS 上运行虚拟化 Linux 系统的工具。 官方称可以把 Lima 理解为 \u0026ldquo;macOS subsystem for Linux\u0026rdquo; 或者 \u0026ldquo;containerd for Mac\u0026rdquo;。\n   安装   在 macOS 主机上最简单的方式是通过 Homebrew 安装  1  brew install lima    我比较喜欢自己构建，会自己手动构建 qemu 以后放在 $HOME/.local 下\n 启动虚拟机  创建一个 default.yaml，内容如下（根据自己主机的情况调整 memory 和 disk 大小）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  cpus:2memory:\u0026#34;10GiB\u0026#34;disk:\u0026#34;100GiB\u0026#34;images:- location:\u0026#34;https://cloud-images.ubuntu.com/impish/current/impish-server-cloudimg-amd64.img\u0026#34;arch:\u0026#34;x86_64\u0026#34;mounts:- location:\u0026#34;~\u0026#34;writable:false- location:\u0026#34;/tmp/lima\u0026#34;writable:truessh:localPort:60006containerd:system:falseuser:falseportForwards:- guestSocket:\u0026#34;/run/user/{{.UID}}/docker.sock\u0026#34;hostSocket:\u0026#34;{{.Home}}/opt/docker/docker.sock\u0026#34;  执行 limactl start ./default.yaml 启动虚拟机  可以通过 ps -ef 看到\n501 1589 1577 0 Sun07PM ttys001 1847:13.31 /usr/local/bin/qemu-system-x86_64 -cpu host -machine q35,accel=hvf -smp 2,sockets=1,cores=2,threads=1 -m 10240 -drive if=pflash,format=raw,readonly=on,file=/usr/local/share/qemu/edk2-x86_64-code.fd -boot order=c,splash-time=0,menu=on -drive file=/Users/nevill/.lima/default/diffdisk,if=virtio -cdrom /Users/nevill/.lima/default/cidata.iso -netdev user,id=net0,net=192.168.5.0/24,dhcpstart=192.168.5.15,hostfwd=tcp:127.0.0.1:60006-:22 -device virtio-net-pci,netdev=net0,mac=52:55:55:63:06:20 -device virtio-rng-pci -display none -device virtio-vga -device virtio-keyboard-pci -device virtio-mouse-pci -parallel none -chardev socket,id=char-serial,path=/Users/nevill/.lima/default/serial.sock,server=on,wait=off,logfile=/Users/nevill/.lima/default/serial.log -serial chardev:char-serial -chardev socket,id=char-qmp,path=/Users/nevill/.lima/default/qmp.sock,server=on,wait=off -qmp chardev:char-qmp -name lima-default -pidfile /Users/nevill/.lima/default/qemu.pid 501 1643 1 0 Sun07PM ?? 0:00.89 ssh: /Users/nevill/.lima/default/ssh.sock [mux] 501 1649 1577 0 Sun07PM ttys001 0:00.01 ssh -F /dev/null -o IdentityFile=\u0026quot;/Users/nevill/.lima/_config/user\u0026quot; -o IdentityFile=\u0026quot;/Users/nevill/.ssh/google_compute_engine\u0026quot; -o IdentityFile=\u0026quot;/Users/nevill/.ssh/id_rsa\u0026quot; -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o NoHostAuthenticationForLocalhost=yes -o GSSAPIAuthentication=no -o PreferredAuthentications=publickey -o Compression=no -o BatchMode=yes -o IdentitiesOnly=yes -o Ciphers=\u0026quot;^aes128-gcm@openssh.com,aes256-gcm@openssh.com\u0026quot; -o User=nevill -o ControlMaster=auto -o ControlPath=\u0026quot;/Users/nevill/.lima/default/ssh.sock\u0026quot; -o ControlPersist=5m -p 60006 127.0.0.1 -- sshfs :/Users/nevill /Users/nevill -o slave -o ro -o allow_other 501 1652 1577 0 Sun07PM ttys001 0:00.01 ssh -F /dev/null -o IdentityFile=\u0026quot;/Users/nevill/.lima/_config/user\u0026quot; -o IdentityFile=\u0026quot;/Users/nevill/.ssh/google_compute_engine\u0026quot; -o IdentityFile=\u0026quot;/Users/nevill/.ssh/id_rsa\u0026quot; -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o NoHostAuthenticationForLocalhost=yes -o GSSAPIAuthentication=no -o PreferredAuthentications=publickey -o Compression=no -o BatchMode=yes -o IdentitiesOnly=yes -o Ciphers=\u0026quot;^aes128-gcm@openssh.com,aes256-gcm@openssh.com\u0026quot; -o User=nevill -o ControlMaster=auto -o ControlPath=\u0026quot;/Users/nevill/.lima/default/ssh.sock\u0026quot; -o ControlPersist=5m -p 60006 127.0.0.1 -- sshfs :/tmp/lima /tmp/lima -o slave -o allow_other 501 1662 1660 0 Sun07PM ttys001 0:00.01 /usr/bin/ssh -F /dev/null -o IdentityFile=\u0026quot;/Users/nevill/.lima/_config/user\u0026quot; -o IdentityFile=\u0026quot;/Users/nevill/.ssh/google_compute_engine\u0026quot; -o IdentityFile=\u0026quot;/Users/nevill/.ssh/id_rsa\u0026quot; -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o NoHostAuthenticationForLocalhost=yes -o GSSAPIAuthentication=no -o PreferredAuthentications=publickey -o Compression=no -o BatchMode=yes -o IdentitiesOnly=yes -o Ciphers=\u0026quot;^aes128-gcm@openssh.com,aes256-gcm@openssh.com\u0026quot; -o User=nevill -o ControlMaster=auto -o ControlPath=\u0026quot;/Users/nevill/.lima/default/ssh.sock\u0026quot; -o ControlPersist=5m -t -q -p 60006 127.0.0.1 -- cd \u0026quot;/Users/nevill\u0026quot; || cd \u0026quot;/Users/nevill\u0026quot; ; exec bash --login 注意到 qemu 进程的存在，还有一些 ssh 进程用来转发端口。\n运行 lima 即可进入虚拟机访问。\n   安装并使用 Docker   在虚拟机里面安装 rootless docker [2]  1 2 3 4 5 6 7 8 9 10 11 12  $ lima nevill@lima-default:/Users/nevill$ curl -fsSL https://get.docker.com/rootless | sh # 启动 docker 服务 nevill@lima-default:/Users/nevill$ systemctl --user daemon-reload nevill@lima-default:/Users/nevill$ systemctl --user restart docker # 虚拟机启动的时候启动容器服务 nevill@lima-default:/Users/nevill$ sudo loginctl enable-linger $(whoami) # 确定 docker 正常运行 nevill@lima-default:/Users/nevill$ docker info   在主机环境中使用 docker  安装 docker cli\n nerdctl 当前还不能完全取代 docker-cli [1]。 至少需要等 kind 能够通过 nerdctl 正常启动我才会替换，目前依然使用 docker-cli 来进行容器、镜像的相关操作。\n 运行 DOCKER_HOST=unix:///Users/nevill/opt/docker/docker.sock docker info 看是否能成功返回结果。\n如果成功可以执行 docker context create lima-default --docker \u0026quot;host=unix:///Users/nevill/opt/docker/docker.sock\u0026quot; 来保存。\n   同 Docker 的兼容性  Lima 会将主机的 $HOME 目录完全映射到虚拟机中，因此在主机的 $HOME 下执行类似 docker run -v $PWD:/somedir 的命令是完全可以正常工作的。\n   Reference   https://github.com/containerd/nerdctl/issues/349 https://rootlesscontaine.rs/getting-started/docker/  ","date":"Nov 29","permalink":"https://nevill.github.io/posts/using-lima-as-docker-destkop-alternative/","tags":null,"title":"Using Lima as Docker Destkop Alternative"},{"categories":null,"contents":"最近在本地尝试Kubernetes 集群的搭建。\n一个主机有两张网卡，在安装完集群以后，发现 Pod 里分配的 IP 全部都是主机第一张网卡的 IP。 而这个环境是 Vagrant + Virtualbox 安装，第一张网卡的 IP 地址也都是固定的。\n开始找解决方案。\n  想到 Pod 的网络是通过 cni 来分配的，也许可以通过改 cni 配置来实现。翻看了半天 cni 的资料，尝试了一下没有成功，以后要加强 cni 的学习。\n  回头看这个图的时候，忽然发现有些 Pod 是能成功分配 IP 的，而那些分配到了相同 IP 的 Pod 在 Spec 定义里都有一个 hostNetwork: true。 确实，10.0.2.15 这个 IP 就是主机第一张网卡上的。翻看 k8s 源代码，发现有 hostNetwork 属性的 Pod 在确定其 IP 时，就是读取所在 node 上的 IP 地址 [1]。\n  Node 节点的信息都由 Kubelet 控制，因此，怎么取 node IP 的过程跟 cni 没关系，而是直接从 Spec 中读取。 而 Spec 中 status.address 是从主机上按照网卡顺序取 IP，或者，通过 \u0026ndash;node-ip 这个参数指定。\n  所以最终的解决方法就是在 kubelet 启动的参数中指定 node-ip 这个参数即可。\n  这么做也有问题，比如这个 IP 地址是动态分配的怎么办？看到有 Issue 讨论 AWS 可以通过 API 解析域名的方式来获取 IP，这些功能是跟厂商绑定的了。\n     参考  [1] pkg/kubelet/kubelet_pods.go : func (kl *Kubelet) generateAPIPodStatus(pod *v1.Pod, podStatus *kubecontainer.PodStatus) v1.PodStatus\n","date":"Oct 15","permalink":"https://nevill.github.io/posts/k8s-hostnetwork-pod-ip/","tags":null,"title":"Kubernetes POD IP"},{"categories":null,"contents":"","date":"Jan 01","permalink":"https://nevill.github.io/articles/","tags":null,"title":"Articles"}]