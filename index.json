[{"categories":null,"contents":"运行一个取字符串地址的程序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // hello.go package main import ( \u0026#34;fmt\u0026#34; ) func main() { str := \u0026#34;Hello Golang!\u0026#34; strPtr := \u0026amp;str fmt.Printf(\u0026#34;address of str = %p\\n\u0026#34;, strPtr) byteArray := []byte(str) fmt.Printf(\u0026#34;address of byte array = %p\\n\u0026#34;, byteArray) fmt.Scanln() }   观察到输出\naddress of str = 0xc00008a210 address of byte array = 0xc0000ac000 这两个地址的值并不相同。\n正好在学习使用 crash utility，可以用来观察一下内存结构\ncrash\u0026gt; rd -32 0xc00008a210 8 c00008a210: 004a3cfc 00000000 0000000d 00000000 .\u0026lt;J............. c00008a220: 005383e0 00000000 00538420 00000000 ..S..... .S..... crash\u0026gt; rd -a 0xc0000ac000 c0000ac000: Hello Golang! 猜测，0xc00008c210 这个指针指向了一个字符串真正的地址，即 0x004a3cfc 才是存放的内存地址。 尝试读取一下：\ncrash\u0026gt; rd -8 0x004a3cfc 32 4a3cfc: 48 65 6c 6c 6f 20 47 6f 6c 61 6e 67 21 4d 61 73 Hello Golang!Mas 4a3d0c: 61 72 61 6d 5f 47 6f 6e 64 69 4d 65 6e 64 65 5f aram_GondiMende_ 果然找到了。\n翻一下代码，有一个 stringStruct\n1 2 3 4 5  // runtime/string.go type stringStruct struct { str unsafe.Pointer len int }   同时，观察到 0xc00008a218 这个地址的值 0x0000000d 即 Hello Golang! 字符串的长度 13。即验证了 0xc00008a210 这个地址对应的结构体。 那么通过 []byte(str) 强制转换以后为什么会返回另外一个内存地址 0xc0000ac000 而没有返回 0x004a3cfc 呢？ 原因也很简单， string 类型应该是不可修改的 (immutable)[1]，也无法通过 \u0026amp;str[i] 来获取其某一个 byte 的地址。\n可以查看一下汇编：\n// go tool compile -S hello.go // ... 0x0085 00133 (hello.go:11)\tMOVQ\t\u0026quot;\u0026quot;.\u0026amp;str+56(SP), CX 0x008a 00138 (hello.go:11)\tMOVQ\t(CX), BX 0x008d 00141 (hello.go:11)\tMOVQ\t8(CX), CX 0x0091 00145 (hello.go:11)\tXORL\tAX, AX 0x0093 00147 (hello.go:11)\tPCDATA\t$1, $0 0x0093 00147 (hello.go:11)\tCALL\truntime.stringtoslicebyte(SB) 0x0098 00152 (hello.go:12)\tCALL\truntime.convTslice(SB) 0x009d 00157 (hello.go:12)\tMOVUPS\tX15, \u0026quot;\u0026quot;..autotmp_29+64(SP) 0x00a3 00163 (hello.go:12)\tLEAQ\ttype.[]uint8(SB), CX 0x00aa 00170 (hello.go:12)\tMOVQ\tCX, \u0026quot;\u0026quot;..autotmp_29+64(SP) 0x00af 00175 (hello.go:12)\tMOVQ\tAX, \u0026quot;\u0026quot;..autotmp_29+72(SP) // ... 这里调用了一个 runtime.stringtoslicebyte\n1 2 3 4 5 6 7 8 9 10 11  func stringtoslicebyte(buf *tmpBuf, s string) []byte { var b []byte if buf != nil \u0026amp;\u0026amp; len(s) \u0026lt;= len(buf) { *buf = tmpBuf{} b = buf[:len(s)] } else { b = rawbyteslice(len(s)) } copy(b, s) return b }   可以看到，最后会调用 copy 将源内容复制到一个新的 []byte 切片中。\n总结一下：\n string 类型结构仅含两个元素，一个指向具体内容的指针和字符串长度 string 类型是不可修改的，所以在强制转换类型的时候发生了复制 写这篇主要目的是展示 crash utility 怎么用 :)  参考： [1] https://go.dev/ref/spec#String_types\n","date":"Jan 11","permalink":"https://nevill.github.io/posts/string-in-go/","tags":null,"title":"String in Go"},{"categories":null,"contents":"随着 Docker Desktop 越来越笨重，我现在已经用 Lima 完全来替换掉它。\n   介绍  Lima 是一个在 macOS 上运行虚拟化 Linux 系统的工具。 官方称可以把 Lima 理解为 \u0026ldquo;macOS subsystem for Linux\u0026rdquo; 或者 \u0026ldquo;containerd for Mac\u0026rdquo;。\n   安装   在 macOS 主机上最简单的方式是通过 Homebrew 安装  1  brew install lima    我比较喜欢自己构建，会自己手动构建 qemu 以后放在 $HOME/.local 下\n 启动虚拟机  创建一个 default.yaml，内容如下（根据自己主机的情况调整 memory 和 disk 大小）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  cpus:2memory:\u0026#34;10GiB\u0026#34;disk:\u0026#34;100GiB\u0026#34;images:- location:\u0026#34;https://cloud-images.ubuntu.com/impish/current/impish-server-cloudimg-amd64.img\u0026#34;arch:\u0026#34;x86_64\u0026#34;mounts:- location:\u0026#34;~\u0026#34;writable:false- location:\u0026#34;/tmp/lima\u0026#34;writable:truessh:localPort:60006containerd:system:falseuser:falseportForwards:- guestSocket:\u0026#34;/run/user/{{.UID}}/docker.sock\u0026#34;hostSocket:\u0026#34;{{.Home}}/opt/docker/docker.sock\u0026#34;  执行 limactl start ./default.yaml 启动虚拟机  可以通过 ps -ef 看到\n501 1589 1577 0 Sun07PM ttys001 1847:13.31 /usr/local/bin/qemu-system-x86_64 -cpu host -machine q35,accel=hvf -smp 2,sockets=1,cores=2,threads=1 -m 10240 -drive if=pflash,format=raw,readonly=on,file=/usr/local/share/qemu/edk2-x86_64-code.fd -boot order=c,splash-time=0,menu=on -drive file=/Users/nevill/.lima/default/diffdisk,if=virtio -cdrom /Users/nevill/.lima/default/cidata.iso -netdev user,id=net0,net=192.168.5.0/24,dhcpstart=192.168.5.15,hostfwd=tcp:127.0.0.1:60006-:22 -device virtio-net-pci,netdev=net0,mac=52:55:55:63:06:20 -device virtio-rng-pci -display none -device virtio-vga -device virtio-keyboard-pci -device virtio-mouse-pci -parallel none -chardev socket,id=char-serial,path=/Users/nevill/.lima/default/serial.sock,server=on,wait=off,logfile=/Users/nevill/.lima/default/serial.log -serial chardev:char-serial -chardev socket,id=char-qmp,path=/Users/nevill/.lima/default/qmp.sock,server=on,wait=off -qmp chardev:char-qmp -name lima-default -pidfile /Users/nevill/.lima/default/qemu.pid 501 1643 1 0 Sun07PM ?? 0:00.89 ssh: /Users/nevill/.lima/default/ssh.sock [mux] 501 1649 1577 0 Sun07PM ttys001 0:00.01 ssh -F /dev/null -o IdentityFile=\u0026quot;/Users/nevill/.lima/_config/user\u0026quot; -o IdentityFile=\u0026quot;/Users/nevill/.ssh/google_compute_engine\u0026quot; -o IdentityFile=\u0026quot;/Users/nevill/.ssh/id_rsa\u0026quot; -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o NoHostAuthenticationForLocalhost=yes -o GSSAPIAuthentication=no -o PreferredAuthentications=publickey -o Compression=no -o BatchMode=yes -o IdentitiesOnly=yes -o Ciphers=\u0026quot;^aes128-gcm@openssh.com,aes256-gcm@openssh.com\u0026quot; -o User=nevill -o ControlMaster=auto -o ControlPath=\u0026quot;/Users/nevill/.lima/default/ssh.sock\u0026quot; -o ControlPersist=5m -p 60006 127.0.0.1 -- sshfs :/Users/nevill /Users/nevill -o slave -o ro -o allow_other 501 1652 1577 0 Sun07PM ttys001 0:00.01 ssh -F /dev/null -o IdentityFile=\u0026quot;/Users/nevill/.lima/_config/user\u0026quot; -o IdentityFile=\u0026quot;/Users/nevill/.ssh/google_compute_engine\u0026quot; -o IdentityFile=\u0026quot;/Users/nevill/.ssh/id_rsa\u0026quot; -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o NoHostAuthenticationForLocalhost=yes -o GSSAPIAuthentication=no -o PreferredAuthentications=publickey -o Compression=no -o BatchMode=yes -o IdentitiesOnly=yes -o Ciphers=\u0026quot;^aes128-gcm@openssh.com,aes256-gcm@openssh.com\u0026quot; -o User=nevill -o ControlMaster=auto -o ControlPath=\u0026quot;/Users/nevill/.lima/default/ssh.sock\u0026quot; -o ControlPersist=5m -p 60006 127.0.0.1 -- sshfs :/tmp/lima /tmp/lima -o slave -o allow_other 501 1662 1660 0 Sun07PM ttys001 0:00.01 /usr/bin/ssh -F /dev/null -o IdentityFile=\u0026quot;/Users/nevill/.lima/_config/user\u0026quot; -o IdentityFile=\u0026quot;/Users/nevill/.ssh/google_compute_engine\u0026quot; -o IdentityFile=\u0026quot;/Users/nevill/.ssh/id_rsa\u0026quot; -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o NoHostAuthenticationForLocalhost=yes -o GSSAPIAuthentication=no -o PreferredAuthentications=publickey -o Compression=no -o BatchMode=yes -o IdentitiesOnly=yes -o Ciphers=\u0026quot;^aes128-gcm@openssh.com,aes256-gcm@openssh.com\u0026quot; -o User=nevill -o ControlMaster=auto -o ControlPath=\u0026quot;/Users/nevill/.lima/default/ssh.sock\u0026quot; -o ControlPersist=5m -t -q -p 60006 127.0.0.1 -- cd \u0026quot;/Users/nevill\u0026quot; || cd \u0026quot;/Users/nevill\u0026quot; ; exec bash --login 注意到 qemu 进程的存在，还有一些 ssh 进程用来转发端口。\n运行 lima 即可进入虚拟机访问。\n   安装并使用 Docker   在虚拟机里面安装 rootless docker [2]  1 2 3 4 5 6 7 8 9 10 11 12  $ lima nevill@lima-default:/Users/nevill$ curl -fsSL https://get.docker.com/rootless | sh # 启动 docker 服务 nevill@lima-default:/Users/nevill$ systemctl --user daemon-reload nevill@lima-default:/Users/nevill$ systemctl --user restart docker # 虚拟机启动的时候启动容器服务 nevill@lima-default:/Users/nevill$ sudo loginctl enable-linger $(whoami) # 确定 docker 正常运行 nevill@lima-default:/Users/nevill$ docker info   在主机环境中使用 docker  安装 docker cli\n nerdctl 当前还不能完全取代 docker-cli [1]。 至少需要等 kind 能够通过 nerdctl 正常启动我才会替换，目前依然使用 docker-cli 来进行容器、镜像的相关操作。\n 运行 DOCKER_HOST=unix:///Users/nevill/opt/docker/docker.sock docker info 看是否能成功返回结果。\n如果成功可以执行 docker context create lima-default --docker \u0026quot;host=unix:///Users/nevill/opt/docker/docker.sock\u0026quot; 来保存。\n   同 Docker 的兼容性  Lima 会将主机的 $HOME 目录完全映射到虚拟机中，因此在主机的 $HOME 下执行类似 docker run -v $PWD:/somedir 的命令是完全可以正常工作的。\n   Reference   https://github.com/containerd/nerdctl/issues/349 https://rootlesscontaine.rs/getting-started/docker/  ","date":"Nov 29","permalink":"https://nevill.github.io/posts/using-lima-as-docker-destkop-alternative/","tags":null,"title":"Using Lima as Docker Destkop Alternative"},{"categories":null,"contents":"最近在本地尝试Kubernetes 集群的搭建。\n一个主机有两张网卡，在安装完集群以后，发现 Pod 里分配的 IP 全部都是主机第一张网卡的 IP。 而这个环境是 Vagrant + Virtualbox 安装，第一张网卡的 IP 地址也都是固定的。\n开始找解决方案。\n  想到 Pod 的网络是通过 cni 来分配的，也许可以通过改 cni 配置来实现。翻看了半天 cni 的资料，尝试了一下没有成功，以后要加强 cni 的学习。\n  回头看这个图的时候，忽然发现有些 Pod 是能成功分配 IP 的，而那些分配到了相同 IP 的 Pod 在 Spec 定义里都有一个 hostNetwork: true。 确实，10.0.2.15 这个 IP 就是主机第一张网卡上的。翻看 k8s 源代码，发现有 hostNetwork 属性的 Pod 在确定其 IP 时，就是读取所在 node 上的 IP 地址 [1]。\n  Node 节点的信息都由 Kubelet 控制，因此，怎么取 node IP 的过程跟 cni 没关系，而是直接从 Spec 中读取。 而 Spec 中 status.address 是从主机上按照网卡顺序取 IP，或者，通过 \u0026ndash;node-ip 这个参数指定。\n  所以最终的解决方法就是在 kubelet 启动的参数中指定 node-ip 这个参数即可。\n  这么做也有问题，比如这个 IP 地址是动态分配的怎么办？看到有 Issue 讨论 AWS 可以通过 API 解析域名的方式来获取 IP，这些功能是跟厂商绑定的了。\n     参考  [1] pkg/kubelet/kubelet_pods.go : func (kl *Kubelet) generateAPIPodStatus(pod *v1.Pod, podStatus *kubecontainer.PodStatus) v1.PodStatus\n","date":"Oct 15","permalink":"https://nevill.github.io/posts/k8s-hostnetwork-pod-ip/","tags":null,"title":"Kubernetes POD IP"},{"categories":null,"contents":"","date":"Jan 01","permalink":"https://nevill.github.io/articles/","tags":null,"title":"Articles"}]