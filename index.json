[{"categories":null,"contents":"随着 Docker Desktop 越来越笨重，我现在已经用 Lima 完全来替换掉它。\n   介绍  Lima 是一个在 macOS 上运行虚拟化 Linux 系统的工具。 官方称可以把 Lima 理解为 \u0026ldquo;macOS subsystem for Linux\u0026rdquo; 或者 \u0026ldquo;containerd for Mac\u0026rdquo;。\n   安装   在 macOS 主机上最简单的方式是通过 Homebrew 安装  1  brew install lima    我比较喜欢自己构建，会自己手动构建 qemu 以后放在 $HOME/.local 下\n 启动虚拟机  创建一个 default.yaml，内容如下（根据自己主机的情况调整 memory 和 disk 大小）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  cpus:2memory:\u0026#34;10GiB\u0026#34;disk:\u0026#34;100GiB\u0026#34;images:- location:\u0026#34;https://cloud-images.ubuntu.com/impish/current/impish-server-cloudimg-amd64.img\u0026#34;arch:\u0026#34;x86_64\u0026#34;mounts:- location:\u0026#34;~\u0026#34;writable:false- location:\u0026#34;/tmp/lima\u0026#34;writable:truessh:localPort:60006containerd:system:falseuser:falseportForwards:- guestSocket:\u0026#34;/run/user/{{.UID}}/docker.sock\u0026#34;hostSocket:\u0026#34;{{.Home}}/opt/docker/docker.sock\u0026#34;  执行 limactl start ./default.yaml 启动虚拟机  可以通过 ps -ef 看到\n501 1589 1577 0 Sun07PM ttys001 1847:13.31 /usr/local/bin/qemu-system-x86_64 -cpu host -machine q35,accel=hvf -smp 2,sockets=1,cores=2,threads=1 -m 10240 -drive if=pflash,format=raw,readonly=on,file=/usr/local/share/qemu/edk2-x86_64-code.fd -boot order=c,splash-time=0,menu=on -drive file=/Users/nevill/.lima/default/diffdisk,if=virtio -cdrom /Users/nevill/.lima/default/cidata.iso -netdev user,id=net0,net=192.168.5.0/24,dhcpstart=192.168.5.15,hostfwd=tcp:127.0.0.1:60006-:22 -device virtio-net-pci,netdev=net0,mac=52:55:55:63:06:20 -device virtio-rng-pci -display none -device virtio-vga -device virtio-keyboard-pci -device virtio-mouse-pci -parallel none -chardev socket,id=char-serial,path=/Users/nevill/.lima/default/serial.sock,server=on,wait=off,logfile=/Users/nevill/.lima/default/serial.log -serial chardev:char-serial -chardev socket,id=char-qmp,path=/Users/nevill/.lima/default/qmp.sock,server=on,wait=off -qmp chardev:char-qmp -name lima-default -pidfile /Users/nevill/.lima/default/qemu.pid 501 1643 1 0 Sun07PM ?? 0:00.89 ssh: /Users/nevill/.lima/default/ssh.sock [mux] 501 1649 1577 0 Sun07PM ttys001 0:00.01 ssh -F /dev/null -o IdentityFile=\u0026quot;/Users/nevill/.lima/_config/user\u0026quot; -o IdentityFile=\u0026quot;/Users/nevill/.ssh/google_compute_engine\u0026quot; -o IdentityFile=\u0026quot;/Users/nevill/.ssh/id_rsa\u0026quot; -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o NoHostAuthenticationForLocalhost=yes -o GSSAPIAuthentication=no -o PreferredAuthentications=publickey -o Compression=no -o BatchMode=yes -o IdentitiesOnly=yes -o Ciphers=\u0026quot;^aes128-gcm@openssh.com,aes256-gcm@openssh.com\u0026quot; -o User=nevill -o ControlMaster=auto -o ControlPath=\u0026quot;/Users/nevill/.lima/default/ssh.sock\u0026quot; -o ControlPersist=5m -p 60006 127.0.0.1 -- sshfs :/Users/nevill /Users/nevill -o slave -o ro -o allow_other 501 1652 1577 0 Sun07PM ttys001 0:00.01 ssh -F /dev/null -o IdentityFile=\u0026quot;/Users/nevill/.lima/_config/user\u0026quot; -o IdentityFile=\u0026quot;/Users/nevill/.ssh/google_compute_engine\u0026quot; -o IdentityFile=\u0026quot;/Users/nevill/.ssh/id_rsa\u0026quot; -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o NoHostAuthenticationForLocalhost=yes -o GSSAPIAuthentication=no -o PreferredAuthentications=publickey -o Compression=no -o BatchMode=yes -o IdentitiesOnly=yes -o Ciphers=\u0026quot;^aes128-gcm@openssh.com,aes256-gcm@openssh.com\u0026quot; -o User=nevill -o ControlMaster=auto -o ControlPath=\u0026quot;/Users/nevill/.lima/default/ssh.sock\u0026quot; -o ControlPersist=5m -p 60006 127.0.0.1 -- sshfs :/tmp/lima /tmp/lima -o slave -o allow_other 501 1662 1660 0 Sun07PM ttys001 0:00.01 /usr/bin/ssh -F /dev/null -o IdentityFile=\u0026quot;/Users/nevill/.lima/_config/user\u0026quot; -o IdentityFile=\u0026quot;/Users/nevill/.ssh/google_compute_engine\u0026quot; -o IdentityFile=\u0026quot;/Users/nevill/.ssh/id_rsa\u0026quot; -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o NoHostAuthenticationForLocalhost=yes -o GSSAPIAuthentication=no -o PreferredAuthentications=publickey -o Compression=no -o BatchMode=yes -o IdentitiesOnly=yes -o Ciphers=\u0026quot;^aes128-gcm@openssh.com,aes256-gcm@openssh.com\u0026quot; -o User=nevill -o ControlMaster=auto -o ControlPath=\u0026quot;/Users/nevill/.lima/default/ssh.sock\u0026quot; -o ControlPersist=5m -t -q -p 60006 127.0.0.1 -- cd \u0026quot;/Users/nevill\u0026quot; || cd \u0026quot;/Users/nevill\u0026quot; ; exec bash --login 注意到 qemu 进程的存在，还有一些 ssh 进程用来转发端口。\n运行 lima 即可进入虚拟机访问。\n   安装并使用 Docker   在虚拟机里面安装 rootless docker [2]  1 2 3 4 5 6 7 8 9 10 11 12  $ lima nevill@lima-default:/Users/nevill$ curl -fsSL https://get.docker.com/rootless | sh # 启动 docker 服务 nevill@lima-default:/Users/nevill$ systemctl --user daemon-reload nevill@lima-default:/Users/nevill$ systemctl --user restart docker # 虚拟机启动的时候启动容器服务 nevill@lima-default:/Users/nevill$ sudo loginctl enable-linger $(whoami) # 确定 docker 正常运行 nevill@lima-default:/Users/nevill$ docker info   在主机环境中使用 docker  安装 docker cli\n nerdctl 当前还不能完全取代 docker-cli [1]。 至少需要等 kind 能够通过 nerdctl 正常启动我才会替换，目前依然使用 docker-cli 来进行容器、镜像的相关操作。\n 运行 DOCKER_HOST=unix:///Users/nevill/opt/docker/docker.sock docker info 看是否能成功返回结果。\n如果成功可以执行 docker context create lima-default --docker \u0026quot;host=unix:///Users/nevill/opt/docker/docker.sock\u0026quot; 来保存。\n   同 Docker 的兼容性  Lima 会将主机的 $HOME 目录完全映射到虚拟机中，因此在主机的 $HOME 下执行类似 docker run -v $PWD:/somedir 的命令是完全可以正常工作的。\n   Reference   https://github.com/containerd/nerdctl/issues/349 https://rootlesscontaine.rs/getting-started/docker/  ","date":"Nov 29","permalink":"https://nevill.github.io/posts/using-lima-as-docker-destkop-alternative/","tags":null,"title":"Using Lima as Docker Destkop Alternative"},{"categories":null,"contents":"最近在本地尝试Kubernetes 集群的搭建。\n一个主机有两张网卡，在安装完集群以后，发现 Pod 里分配的 IP 全部都是主机第一张网卡的 IP。 而这个环境是 Vagrant + Virtualbox 安装，第一张网卡的 IP 地址也都是固定的。\n开始找解决方案。\n  想到 Pod 的网络是通过 cni 来分配的，也许可以通过改 cni 配置来实现。翻看了半天 cni 的资料，尝试了一下没有成功，以后要加强 cni 的学习。\n  回头看这个图的时候，忽然发现有些 Pod 是能成功分配 IP 的，而那些分配到了相同 IP 的 Pod 在 Spec 定义里都有一个 hostNetwork: true。 确实，10.0.2.15 这个 IP 就是主机第一张网卡上的。翻看 k8s 源代码，发现有 hostNetwork 属性的 Pod 在确定其 IP 时，就是读取所在 node 上的 IP 地址 [1]。\n  Node 节点的信息都由 Kubelet 控制，因此，怎么取 node IP 的过程跟 cni 没关系，而是直接从 Spec 中读取。 而 Spec 中 status.address 是从主机上按照网卡顺序取 IP，或者，通过 \u0026ndash;node-ip 这个参数指定。\n  所以最终的解决方法就是在 kubelet 启动的参数中指定 node-ip 这个参数即可。\n  这么做也有问题，比如这个 IP 地址是动态分配的怎么办？看到有 Issue 讨论 AWS 可以通过 API 解析域名的方式来获取 IP，这些功能是跟厂商绑定的了。\n     参考  [1] pkg/kubelet/kubelet_pods.go : func (kl *Kubelet) generateAPIPodStatus(pod *v1.Pod, podStatus *kubecontainer.PodStatus) v1.PodStatus\n","date":"Oct 15","permalink":"https://nevill.github.io/posts/k8s-hostnetwork-pod-ip/","tags":null,"title":"Kubernetes POD IP"},{"categories":null,"contents":"","date":"Jan 01","permalink":"https://nevill.github.io/articles/","tags":null,"title":"Articles"}]