<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on 兵器谱 BingQiPu</title><link>https://nevill.github.io/posts/</link><description>Recent content in Posts on 兵器谱 BingQiPu</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 27 Nov 2022 12:18:54 +0800</lastBuildDate><atom:link href="https://nevill.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Unraid Passthrough</title><link>https://nevill.github.io/posts/unraid-passthrough/</link><pubDate>Sun, 27 Nov 2022 12:18:54 +0800</pubDate><guid>https://nevill.github.io/posts/unraid-passthrough/</guid><description>总结记录一下在 unRAID(v6.11) 中如何直通核显 gpu，usb 设备等。
CPU: AMD R7-5700G Motherboard: Asus TUF Gaming B550 Plus WIFI II Memory: 2 x 32G DDR3200 主机配置 设置 unRAID 启动方式为 Legacy。在主机的 BIOS 设置打开 CSM / Legacy Boot 等选项。 设置内置显卡为主要启动项，打开 multiple display 选项，并分配最大的共享内存。 打开 SVM（虚拟化支持）选项。 设置 unRAID 进入 unRAID 中配置 System Devices 分组，并选定 Bind Selected to IOMMU 中分得越开越利于后续步骤，具体操作步骤可以参考[1]。需要注意的是，通过反复拔插确定好需要直通的 usb port 的位置以及对应的 usb controller，后面整个直通给虚拟机，这样子虚拟机就可以轻松使用 usb 设备了。</description></item><item><title>String in Go</title><link>https://nevill.github.io/posts/string-in-go/</link><pubDate>Tue, 11 Jan 2022 17:08:18 +0800</pubDate><guid>https://nevill.github.io/posts/string-in-go/</guid><description>运行一个取字符串地址的程序
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // hello.go package main import ( &amp;#34;fmt&amp;#34; ) func main() { str := &amp;#34;Hello Golang!&amp;#34; strPtr := &amp;amp;str fmt.Printf(&amp;#34;address of str = %p\n&amp;#34;, strPtr) byteArray := []byte(str) fmt.Printf(&amp;#34;address of byte array = %p\n&amp;#34;, byteArray) fmt.Scanln() } 观察到输出
address of str = 0xc00008a210 address of byte array = 0xc0000ac000 这两个地址的值并不相同。
正好在学习使用 crash utility，可以用来观察一下内存结构</description></item><item><title>Using Lima as Docker Destkop Alternative</title><link>https://nevill.github.io/posts/using-lima-as-docker-destkop-alternative/</link><pubDate>Mon, 29 Nov 2021 13:05:34 +0800</pubDate><guid>https://nevill.github.io/posts/using-lima-as-docker-destkop-alternative/</guid><description>随着 Docker Desktop 越来越笨重，我现在已经用 Lima 完全来替换掉它。
介绍 Lima 是一个在 macOS 上运行虚拟化 Linux 系统的工具。 官方称可以把 Lima 理解为 &amp;ldquo;macOS subsystem for Linux&amp;rdquo; 或者 &amp;ldquo;containerd for Mac&amp;rdquo;。
安装 在 macOS 主机上最简单的方式是通过 Homebrew 安装 1 brew install lima 我比较喜欢自己构建，会自己手动构建 qemu 以后放在 $HOME/.local 下
启动虚拟机 创建一个 default.yaml，内容如下（根据自己主机的情况调整 memory 和 disk 大小）
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 cpus:2memory:&amp;#34;10GiB&amp;#34;disk:&amp;#34;100GiB&amp;#34;images:- location:&amp;#34;https://cloud-images.</description></item><item><title>Kubernetes POD IP</title><link>https://nevill.github.io/posts/k8s-hostnetwork-pod-ip/</link><pubDate>Fri, 15 Oct 2021 12:48:08 +0800</pubDate><guid>https://nevill.github.io/posts/k8s-hostnetwork-pod-ip/</guid><description>最近在本地尝试Kubernetes 集群的搭建。
一个主机有两张网卡，在安装完集群以后，发现 Pod 里分配的 IP 全部都是主机第一张网卡的 IP。 而这个环境是 Vagrant + Virtualbox 安装，第一张网卡的 IP 地址也都是固定的。
开始找解决方案。
想到 Pod 的网络是通过 cni 来分配的，也许可以通过改 cni 配置来实现。翻看了半天 cni 的资料，尝试了一下没有成功，以后要加强 cni 的学习。
回头看这个图的时候，忽然发现有些 Pod 是能成功分配 IP 的，而那些分配到了相同 IP 的 Pod 在 Spec 定义里都有一个 hostNetwork: true。 确实，10.0.2.15 这个 IP 就是主机第一张网卡上的。翻看 k8s 源代码，发现有 hostNetwork 属性的 Pod 在确定其 IP 时，就是读取所在 node 上的 IP 地址 [1]。
Node 节点的信息都由 Kubelet 控制，因此，怎么取 node IP 的过程跟 cni 没关系，而是直接从 Spec 中读取。 而 Spec 中 status.</description></item></channel></rss>